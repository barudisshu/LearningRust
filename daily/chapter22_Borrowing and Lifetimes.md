本章覆盖有：

- “租借，borrowing”和“生命周期，lefetime”的概念
- 折磨系统软件的租借典型错误是哪些
- 如何通过租借checker，Rust的严格语法来避免这种典型错误
- 如何通过插入语句块来约束租借的作用域(scope)
- 为什么函数返回的引用需要生命周期指示符(specifiers)
- 如何给函数使用生命周期指示符(lifetime specifiers)，它们表示什么
- 租借checker的任务是什么

## Ownership and Borrowing

上一章介绍到，当将变量`a`赋值给`b`时，会有两种情况：如果它们类型是可拷贝的(copyable)，它就实现了`Copy`特质(当然也肯定实现了`Clone`)；如果它们的类型不可拷贝(non-copyable)，则没有实现`Copy`(`Clone`可能实现，也可能没有)。

第一种情况，用到拷贝语义(copy semantics)。意味着，在赋值过程中，当`a`保留它对象的所有权(ownership)，一个新的对象被创建，初始化值等同于`a`的值，以及`b`获得这些新的对象的所有权。当`a`和`b`离开它的作用域时，它们拥有的对象被销毁(又叫dropped)。

相反，第二种情况，用到移动语义(move semantics)。意味着，在赋值过程中，`a`将它的所有权移交给了`b`，不会有新对象的创建，`a`不再可访问。当`b`离开它的作用域时，它拥有的对象被销毁。当`a`离开它的作用域，不发生任何事情。

所有这些保证了合适的内存管理，只要没有引用被使用到。

但看看这个代码，

```rust
let n = 12;
let ref_to_n = &n;
```

第一条语句后，变量`n`拥有一个数。

第二条语句后，变量`ref_to_n`拥有一个引用，该引用指向同一个由`n`引用的数。它是一个所有权吗？

它不能作为一个所有权，因为这个数早已经由`n`所拥有，如果同时被这个引用所“拥有”，它将会被销毁两次。因此，类似这样的引用不能“拥有”对象。

表达式`n`和`*ref_to_n`指向同一个对象，但仅`n`拥有这个对象。变量`ref_to_n`可以访问这个对象，但不是“拥有”这个对象。这种概念称为**租借，borrowing**。我们说`ref_to_n`借了`n`拥有的数。这种租借，开始于引用指向该对象，结束于该对象的销毁。

关于可变性(mutability)，有两种类型的borrowing：

```rust
let mut n = 12;
let ref1_to_n = &mut n;
let ref2_to_n = &n;
```

这段程序中，`ref1_to_n`将`n`拥有的值，租借为 __mutably__ 的值，以及`ref2_to_n`租借为 __immutably__ 的值。第一种是可变租借(mutable borrowing)，第二种是不可变租借(immutable borrowing)。可变租借仅能从可变变量中获取。

## Object Lifetimes




































