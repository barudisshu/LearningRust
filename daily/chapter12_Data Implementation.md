本章覆盖有：

- 如何知道栈空间分配的各种类型的对象的字节数
- 如何在外部模块缩减声明函数访问的路径
- 原生对象类型存储了多少个bit
- 什么时候一个对象会被存储在内存
- 为什么填充(padding)会增加某些对象的大小
- Vector是如何实现的

## Discovering the Size of Objects

给定一个源文件，以及源代码按照Rust语言规范，Rust编译器任意将其生成目标机器码。

因此，对于一个变量，它没有定义会使用多少bit内存，也没有定义在内存哪个位置分配。编译器甚至将变量从内存中移除，只要它不再被使用，或被驻留在寄存器中。

下面看一个典型的Rust程序长度的实现。

Rust有一些可用特性：

```rust
print!("{} ", std::mem::size_of::<i32>());
print!("{} ", std::mem::size_of_val(&12));
```

结果将输出： “4 4”。

第一条语句，编译器引入了标准库模块`std`，然后跟着子模块`mem`(“memory”的缩写)，接着使用它的泛型函数`size_of`。

该泛型函数接受了类型参数`i32`，然后编译成对应的具体函数。该函数返回类型占用的字节数(也说“十进制的bit”)。该函数在行内调用，因此生成的代码仅是一个常数。实际上，一个32位占4个字节。

第二条语句，编译器进入同样的类库模块，以及访问了泛型函数`size_of_val`(顾名思义，值的大小)。这里类型参数由具体调用的参数推断确定。

当具体的生成的函数`size_of_val`被调用，会传递一个不可变的对象引用参数。然后返回对象字节大小。


## The `use` Directive

在一段代码中如果要多处指定标准库函数，可以方便地使用`use`指令导入到当前范围。

上一段例子可以复写为：

```rust
use std::mem;
print!("{} ", mem::size_of::<i32>());
print!("{} ", mem::size_of_val(&12));
```

或写成这样：

```rust
use std::mem::size_of;
use std::mem::size_of_val;
print!("{} ", size_of::<i32>());
print!("{} ", size_of_val(&12));
```

Rust关键字`use`的用法和C++的`using`关键字类似。

```rust
use std::mem::*;
print!("{} ", size_of::<i32>());
print!("{} ", size_of_val(&12));
```

星号这里作为一个统配导入处理。


## The Sizes of the Primitive Types

现在可以想象下原生类型对象的大小：

```rust
use std::mem::*;
print!("{} {} {} {} {} {} {} {} {} {} {} {}",
	size_of::<i8>(),
	size_of::<u8>(),
	size_of::<i16>(),
	size_of::<u16>(),
	size_of::<i32>(),
	size_of::<u32>(),
	size_of::<i64>(),
	size_of::<u64>(),
	size_of::<f32>(),
	size_of::<f64>(),
	size_of::<bool>(),
	size_of::<char>());
```

在任何计算机，会打印输出：`1 1 2 2 4 4 8 8 4 8 1 4`。

某些其它类型数据的大小，由编译器所在的硬件设备平台所决定：

```rust
use std::mem::*;
print!("{} {} {} {}",
	size_of::<isize>(),
	size_of::<usize>(),
	size_of::<&i8>(),
	size_of::<&u32>());
```

在一个64位系统，打印输出：`8 8 8 8`，而在32位系统，打印：`4 4 4 4`。

后两个打印的是一个引用值。独立于所引用的对象，一个引用(又名“指针”)拥有内存地址大小。

## The Representation of Primitive Types

Rust不鼓励访问内部对象的表述，同时也难于做到。但有一个技巧可以做到这点。

```rust
fn as_bytes<T>(o: &T) -> &[u8] {
	unsafe {
		std::slice::from_raw_parts(
			o as *const _ as * const u8,
			std::mem::size_of::<T>())
	}
}
println!("{:?}", as_bytes(&1i8));
println!("{:?}", as_bytes(&2i16));
println!("{:?}", as_bytes(&3i32));
println!("{:?}", as_bytes(&(4i64 + 5 * 256 + 6 * 256 * 256)));
println!("{:?}", as_bytes(&'A'));
println!("{:?}", as_bytes(&true));
println!("{:?}", as_bytes(&&1i8));
```

在x86_64架构系统中，可能会打印：

```
[1]
[2, 0]
[3, 0, 0, 0]
[4, 5, 6, 0, 0, 0, 0, 0]
[65, 0, 0, 0]
[1]
[129, 165, 54, 102, 23, 86, 0, 0]
```

泛型函数`as_bytes`使用了某些我们没见过的Rust结构，这里不解析，目前的知识还不足以理解它的用法。简单来说，它接受一个任意类型的参数引用，并返回该所引用的对象的字节序列表述。打印任意对象的字节序列后发现，这些对象序列被存储在内存中。

首先，一个`i8`的值1存储一个字节，在其他任何硬件架构也是一样。

然后，一个`i16`的值2存储两个字节，第一个字节是2，第二个字节是0。除目前任何32位或64位处理器都一样，但仅限于“低位优先(little-endian)”硬件架构，会将多字节的数放在低位。相反，“大头优先(big-endian)”的存储顺序方式的硬件架构会打印`[0, 2]`。

类似地行为出现在接下来的打印行。

注意，一个`char`作为32位数字存储，包含Unicode码。`bool`作为单个字节存储，即1位`true`，0位`false`。

最后，最后一条语句打印一个`i8`数字的地址。在64位处理器，该地址包含8个字节。

## Location of Bytes in Memory

你也可以发现任何对象的虚拟内存的位置，即它的地址：

```rust
let b1 = true;
let b2 = true;
let b3 = false;
print!("{} {} {}",
	&b1 as *const bool as usize,
	&b2 as *const bool as usize,
	&b3 as *const bool as usize)
```

在64位系统，将会输出三个巨大的数，像`140727116566237 140727116566238 140727116566239`。相反，在32位系统，输出三个小于5百万的数。

下面是这三个对象的地址表述：

|Absolute address 	|Binary value 	|Variable name 	|Type     |
|:------------------|:--------------|:--------------|--------:|
|`140727116566237` 	|`0000_0000` 	|`b3` 			|`bool`   |
|`140727116566238` 	|`0000_0001` 	|`b2` 			|`bool`   |
|`140727116566239` 	|`0000_0001`	|`b1` 			|`bool`   |

三个对象中每个对象仅占一个字节。最先打印的数是变量`b1`的地址；变量`b2`的地址；变量`b3`的地址。如其所示，这三个数是连续的，意味着这三个数被连续地分配在虚拟内存地址上。

你会发现三个地址按照降序排列，意味着对象的分配，以越来越低位的方式。这些对象分配在栈上，因此看到栈从低位增长。

第一个数包含`true`值，由1字节表示。它由一个7位全为0的以及1位为1的值表示。类似地，第二个值也一样。第三个值`false`，则由全为0的8位值表示。

几乎所有现代处理器要求基础数据要有特定的内存位置，因此Rust放置这些对象在内存，以方便实现处理器的访问。

典型地对齐规则是：“每个原生类型的对象，必须要有一个地址，该地址是它自身大小的倍数”。

因此，占一个字节的对象，可能会放置在任何地方，占两个字节的对象，仅可以放置在偶数位地址，占四个字节的对象，仅可以放置在以4为倍数的地址，以及占8个字节的对象，仅可以放置在以8位倍数的地址。

另外，大对象通常有一个16倍的地址。

因此，这种对齐规则会创建无用的空间，称之为“填充(padding)”。


## Sizes of Composite Data Types

当有一个组合对象序列时，出现结构填充(padding)的效果：

```rust
enum E1 { E1a, E1b };
enum E2 { E2a, E2b(f64) };
use std::mem::*;
print!("{} {} {} {} {} {}",
	size_of_val(&[0i16; 80]),
	size_of_val(&(0i16, 0i64)),
	size_of_val(&[(0i16, 0i64); 100]),
	size_of_val(&E1::E1a),
	size_of_val(&E2::E2a),
	size_of_val(&vec![(0i16, 0i64); 100]));
```

结果打印输出：“`160 16 1600 1 16 24`”。

这意味着：

- 一个80长度的16位数组占160字节，即是 `80 * 2`，这里没有出现浪费；
- 







































































