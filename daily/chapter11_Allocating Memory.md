本章覆盖有：

- 各种各样的内存分配，性能特性，局限性
- 如何给一个对象指定那种内存分配
- 引用和Box的区别

## The Various Kinds of Allocation

要理解Rust语言，也可以说其它系统语言，例如C语言，对于理解内存分配是重要的，例如静态分配(static allocation)，栈分配(stack allocation)，堆分配(heap allocation)。

本章完全致力于该类问题。另外，我们将看到四种内存分配：

- In processor registers
- Static
- In the stack
- In the heap

在C或C++语言，静态分配指的是全局变量和使用`static`关键字声明的变量；栈分配是所有non-static本地变量，以及函数参数；堆分配则是调用了C语言标准库`malloc`函数的，或C++操作符的。

## Linear Addressing

任何计算机硬件，有一块可读和可写内存，即RAM，它由一系列长字节构成，由它们的地址访问。内存第一个字节位置为0，最后一个字节的位置等于内存长度减一。

为了简明起见，目前有两种类型的计算机：

	- 同一时刻单一线程，该进程直接使用物理内存地址。这称为“实时内存系统(real-memory systems)”。
	- 多道程序操作系统，为每个进程提供一个虚拟地址空间。这类称为“虚拟内存系统(virtual-memory systems)”

对于第一种计算机类型，现在仅作为控制器使用，没有实质上的操作系统(所以这类也称为“裸机bare-metal system”)，或者是一个系统驻留在系统的一小块，这种内存操作系统的地址跟应用程序的差不多大。

对于第二种计算机类型，访问内存的能力由操作系统控制，它运行在一个privileged mode(即权限模式，也称为protected mode，或kernel mode)，它将内存的一部分分配给各个正在运行的进程。

至此，在多道程序操作系统，进程“看见”的内存跟操作系统“看见”的内存不一样。操作系统是一个shell，或称为壳。操作系统给予进程权限访问的内存有200多个字节，操作系统满足这种需求由该驻留的进程实现。也就是说，一段机器地址300到499的内存，操作系统和这个分配了200字节的进程通信，但不是和内存的开始地址300通信。实质上每个进程有一个特定的地址空间，称为“virtual”，操作系统对物理内存的映射，称为“real”。

实际上，当一个进程访问操作系统的内存，操作系统只是保留该进程内存空间的一部分，不会有真实内存提供给该进程。因此，对于非常大的内存部分，这个分配也非常快。

只要进程尝试访问内存，即使是初始化为0，操作系统意识到进程是访问虚拟内存片段以及没有映射真实内存，立即为虚拟内存响应真实内存片段。

因此，进程的处理没有直接作用在真实的内存上，而是作用在操作系统提供的虚拟内存上，虚拟内存(虚拟存储)包含对真实地址的映射。

实际上，通常一个单一进程的虚拟内存甚至大于计算机的整个实时内存。例如，计算机可以有一个10亿字节的物理内存，对于该计算机上跑4个进程，每个进程可以有30亿字节的虚拟内存空间。如果所有的虚拟内存映射到真实内存，要处理这种情况，要求有12亿字节的内存。相反，虚拟内存的大部分字节没有被映射到真实内存；仅实际上被用于进程的字节才被映射到真实内存。只要进程开始使用它们的内存地址空间片段，以及没有被映射到真实内存时，操作系统为该虚拟内存片段响应真实的内存。

因此，每次当一个进程访问地址，不论是读或写，如果该地址属于一个虚拟内存片段(实际上叫做“页”)被驻留并映射真实内存的对应片段，进程立即访问这个真实内存；相反，如果这个驻留的页没有被映射，在允许访问之前，操作系统踢掉(kicks in)这个页，机制上叫做“page fault”，通过这种机制，操作系统分配一个真实内存页并将其映射到包含访问地址的虚拟内存页上；若是访问地址不属于进程内存空间部分上的驻留页，会出现地址错误(通常称为“segmentation fault”)。通常，地址错误导致进程的立即中止。

当然，如果程序使用内存太过随意，操作系统需要花费大量时间来做mapping，导致处理的巨大下降，甚至会由于内存不足而中断。

因此，在现代计算机中，都是单进程和多进程集于一身，每个进程“看到”它自己的内存像字节数组一样。一种是真实内存，一种是虚拟内存，但无论它是一个连续地址空间(contiguours address space)，或通常所说的“线性地址(linear addressing)”。区别于旧的计算机系统，现在计算机使用了一个“分段(segmented)”地址空间，编程者使用起来更麻烦。

所有这些都是为了曾清，在一个虚拟内存系统中，操作系统对内存分配管理的操作，是由虚拟内存到真实内存的映射。尽管现在还没有讨论跟多关于内存的分配，我们这里将内存分配定义为：由进程“发现”了驻留内存的一个片段，并关联这个片段到一个对象的操作。

## Static Allocation

尽管，有各种各样的内存分配机制。

最简单的内存分配机制是静态分配(static allocation)。根据这种机制，编译器决定了程序的每个对象需要多少个字节，以及安全地从地址空间获取相应的字节序列。因此，每个变量的地址在编译期确定。下面是一些例子：

```rust
static _A: u32 = 3;
static _B: i32 = -1_000_000;
static _C: f64 = 5.7e10;
static _D: u8 = 200;
```

`static`关键字类似于`let`，都用于声明一个变量，选择性地初始化。

`static`和`let`的不同在于：

- `static`使用了静态分配，`let`使用了栈分配。
- `static`要求显式指定变量的类型，在`let`中不是必须的。
- 常规代码不能改变一个静态变量的值，即使用了`mut`指定。因此，基于安全考虑，Rust中的静态变量通常是immutable的。
- 代码风格上要求静态变量的命名仅能包含大写字母，以及用下划线划分。违反这个规则，编译器会报一个警告。

上面四点，这里我们仅看第一个，分配的方式。

`_A`和`_B`变量带有4个字节，`_C`8个字节，`_D`带有1个字节。如果进程的开始地址是0，编译器会给`_A`分配地址0，`_B`地址是4，`_C`地址是8，`_D`地址是16，总共在编译期分配了17个字节。

当程序开始执行，进程向操作系统访问使用17个字节的内存。然后，在执行期间，不会有更多的内存请求被处理。当进程结束，进程的所有内存会自动释放给操作系统。

静态分配的缺陷是不能创建递归函数。进一步讲，如果一个函数的参数和本地变量是静态指派的，它们只有一份拷贝，当递归函数调用自身，它不能为这些参数和本地变量提供另一份拷贝。

静态分配的另一个缺陷是所有字程序的所有变量被分配在程序的开始，如果程序包含很多变量，但实际执行仅使用了一小部分，大多数变量作了无用的分配，造成该程序的内存饥渴。

典型地，`static`变量的修改是不安全的(unsafe)。

因此，在Rust中，`static`使用得不是特别多。

然后，静态分配被广泛用于其他两种数据：所有可执行二进制代码(executable binary code)，以及所有字符串字面量。


## Stack Allocation

由于静态分配的不足，Rust将对象指派到“stack”里面，每次使用`let`关键字声明变量，每次一个参数被传递给一个函数调用。这里所谓的“stack”是每个进程地址空间的片段。

实际上，每个线程也有一个stack，而不是每个进程都有一个stack。如果操作系统支持线程，则每个程序运行，一个进程被创建，一个线程会被创建并在该进程内部运行。之后，在同一个进程内部，可以创建和启动其它线程。每一次一个线程被创建(包含进程的主线程)，会请求操作系分配一份地址空间片段，它是线程的stack。在真实内存系统(裸机)中，仅会有一个stack被创建用于执行程序。

每个线程保留栈末端的地址。典型地，值较高的一端被认为是堆栈的底部，值较低的一端被认为是堆栈的顶部。

让我们看如下代码，类似前面那个，但使用了栈分配而不是静态分配：

```rust
let _a: u32 = 3;
let _b: i32 = -1_000_000;
let _c: f64 = 5.7e10;
let _d: u8 = 200;
```

该段代码仅有一个线程。现在假设这个线程有一个仅100个字节的stack，地址范围在`[500, 600)`。当程序运行，这4个变量从栈的底部开始分配，即从600开始。






























