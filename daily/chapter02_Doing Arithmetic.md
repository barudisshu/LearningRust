本章覆盖：

- 整数和浮点四则运算
- 多个语句程序编写
- 打印多行

## Adding Integer Numbers

```rust
print!("{} + {} = {}", 34, 80, 80 + 34);
```

```rust
print!("{}", (23 - 6) 5 5 + 20 * 30 / (3 + 4));
```

## Floating-Point Arithmetic

```rust
print!("The sum is {}", 80.3 + 24.8);       // the sum is 115.1
print!("The sum is {}", 80.3 + 34.9);       // the sum is 115.9999999  浮点值计算，参考计算机二进制表示法 
print!("{}", (23. - 6.) % 5. + 20. * 30. / (3. + 4.));  // the print is 87.71428571428571
```

为什么？

在数字字面量后面加一个 `.`后，它将被转换为浮点型字面量，值不变。优先级和整数四则运算相同，尽管除法有不同的结果。

让我们看看表达式是如何执行的。

`23. - 6.` 和 `3. + 4.`的求值和整数类似。
`17. % 5.，2.`的求值和整数类似。该操作在C语言中不支持，对应于C语言的`fmod(17., 5.)`。
`"20. * 30.",600.`的求值和整数类似。
`600. / 7.`的求值，既不会得到二进制计数法，也不会得到十进制计数法。内部得到一个近似二进制的格式；通过Rust可以将该数值转换为十进制格式，你将得到一个`85.71428571428571`。
最后 `2.`被添加到二进制数值，得到的数值不能精确表示，所以它按照上面的方式打印出来。

和C语言不通，Rust不能简单地混入整数和浮点数。下述语句会获得编译错误：

```rust
print!("{}", 2.7 + 1);
```

最简单的方式是加一个点：

```rust
print!("{}", 2.7 + 1.);
```

和其他语言不同，在遇到两个类型不同的操作时，机器语言会隐式将数字1转换为浮点型，或者，将1作为常量，在编译器再转换为浮点型。然而在Rust中，这种操作必须是显式的(explicit)。

最后，`%`操作，表示模数(modulo)，更接近的释义是取余(remainder)。数学中的取余操作对负数有不同的行为。在Rust中`%`和C相同。

```rust
print!("{} {}", -12 % 10, -1.2 % 1.);
```

输出为： "-2 -0.1999999999999996"

## Sequences of Statements

Rust推崇下面的习惯：
- 函数内4个空格的缩进；
- 避免语句内连续的空格；
- 不超过80 columns的宽度，尽可能将长语句拆分为几行。

## Breaking Literal Strings

```rust
println!("{}", "This"
    "is not allowed");
```
上述在Rust中不能像C那样并列，该语句是不合法的。

```rust
println!("{}", "These
    are
    three lines");
```

上述将输出：

These
    are
    three lines

```rust
println!("{}", "This \
    is \
    just one line");
```

上述将输出：

This is just one line



























